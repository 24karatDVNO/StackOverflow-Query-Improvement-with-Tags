<p>The problem was we had separate folders in <code>App_Code</code> for different code languages. This is why in the error message, it said "App_SubCode_CS..." instead of "App_Code...", because the specific class came from a CS code folder (for c# code). Each of these code folders (defined in web.config) get compiled into its own assembly.</p>

<p>Normally when you don't have multiple code folders AppCode, ASP.NET is able to serialize and deserialize objects compiled at different times or on different servers because the assembly name ("AppCode.randomstring") is stored with the class name in the serialized output. On deserialization, the framework calls <code>System.Type.GetType()</code> on the assembly + class name, and that function has a special case to handle assembly names starting with <code>App_Code</code>, where if it doesn't find an assembly named exactly the same, but it does find one that starts with App_Code, it uses that assembly to load the class.  </p>

<p>When you have language folders in <code>App_Code</code>, the generated assemblies are named like: <code>App_SubCode_FOLDERNAME.randomstring</code>, and the framework doesn't seem to handle this case.  So if you have 2 webservers sharing a Sql backed session, class Foo is compiled as <code>"App_SubCode_FN.random1, Foo"</code> on server A, and <code>"App_SubCode_FN.random2, Foo"</code> on server B.  If a user gets a Foo in his session from server A, and then his next request goes to server B, server B will be unable to deserialize the Foo because it can't find an assembly named <code>"App_SubCode_FN.random1"</code>.</p>

<p>The problem can be solved by getting rid of your old VB code (allowing app code to be compiled into a single assembly that .NET plays more nicely with), or by writing a custom SerializationBinder + a custom implementation of the Sql Server backed session.</p>