<p>In general, a static object is "created" by the compiler at compile time. Its behavior as to program exit is likely to be different across languages. For example, in C, there is no special handling at all (and AFAIK that's also true for Objective-C). Often these objects "live" in a read-only memory area that the compiler created and "attached" to the program. When the program is loaded into memory this read-only area is mapped into the program's memory which is a very fast operation. For example, all the static strings (as in <code>printf("I'm a static string.");</code>) in C are treated that way.</p>

<p>Then there's <em>the</em> stack, aka call stack, and <em>a</em> stack. A stack in general is just a data structure, aka LIFO (last-in-first-out). The call stack is indeed created by the OS and is normally limited in size. It stores all the information that are necessary for function call. That mean for each function call, its arguments and other info is "pushed" to the stack (put on top of the stack) and a little space for the function variables is reserved. Once the function returns, all this stuff is removed and only the return value is left (though even this is not always true, often the return value is passed in a CPU register).</p>

<p>You <em>can</em> store values to the stack, and languages like C++ even allow you to store <em>objects</em> on the stack. They "automatically" get cleaned once its enclosing function returns.</p>

<p>You can store also store a pointer to such an object living in the stack in another variable as well. But what you probably mean is that <em>normally</em> you create an object in the heap (e.g. via <code>new</code> in Java, C++, C#, etc. or <code>alloc</code> in Objective-C) and you get a pointer to that object in return.</p>

<p>Back to the start: static objects are known to the compiler at compile time, but everything that has to do with heap and stack is by definition only known at <em>run time</em>.</p>