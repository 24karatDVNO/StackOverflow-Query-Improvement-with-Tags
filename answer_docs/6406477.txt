<p>In C++, you have to manage the memory allocation all on you own, there is no garbage collection of bits you have forgotten to clean up as java/C# and any other modern language has. If you lose track of memory, at best it's leaked, at worst, you continue to use it while something else does. It's a hard problem to solve, very few, if any, C++ programers get this right, so smart pointers and other esoteric advanced magic is performed to get around these issues in C++. @yi_H is correct, get to understand the basics of basic memory allocation, so you know why Smart Pointers are such a good idea.</p>

<p>Without smart pointers, while a few of the answers above have eluded to it, "ownership" is the most critical thing to understand. Whenever you have a pointer to a block of memory, you must know who owns it. If you own it, you must free it before it goes out of scope or it's lost. If you give someone else a copy of it, ensure that you define who owns it, and when the owner can/will/should free it. If you cannot do this, you are hosed. As a rule, C++ libraries are notoriously bad at documenting this, so in the absence of clear information, assume you do not own it (Do not delete it and potentially create a memory leak) in preference to deleting it and creating hard to find defects. Use Valgrind to find memory leaks on the working program.  </p>

<p>To avoid the worst pitfalls, obey some simple rules. Use locals and references in preference to heap (new). When returning allocated memory, clearly document the ownership and life cycle of the allocated memory. Avoid making copies of pointers to allocated memory, copy the data where possible. When making copies of pointers, make the scope as small and short life time ass possible. Much use of pointers is done (badly) in the name of efficiency- a program that runs slowly is far more efficient that one that randomly core dumps.</p>

<p>i.e. Limit the use of the keyword "new". </p>