<p>Whenever the system performs a garbage-collection of a particular generation, it must examine every single object that might hold a reference to any object of that generation.  In many cases, old objects will only hold references to other old objects; if the system is doing a Gen0 collection it can ignore any objects which only hold references to those of Gen1 and/or Gen2.  Likewise if it's doing a Gen1 collection it can ignore any objects which only hold references to Gen2.  Since examination and tagging of objects represents a large portion of the time required for garbage collection, being able to skip older objects entirely represents a considerable time savings.</p>

<p>Incidentally, if you're wondering how the system "knows" whether an object might hold references to newer objects, the system has special code to set a couple bits in each object's descriptor if the object is written.  The first bit is reset at each garbage collection, and if it's still reset at the next garbage collection the system will know it can't contain any references to Gen0 objects (since any objects that existed when the object was last written and weren't cleared out by the previous collection will be Gen1 or Gen2).  The second bit is reset at each Gen1 garbage collection and if it's still reset at the next Gen1 garbage collection, the system will know it can't contain any references to Gen0 or Gen1 objects (any objects to which it holds references are now Gen2).  Note that the system doesn't know or care whether the information that was written to an object included a Gen0 or Gen1 reference.  The trap required when writing to an untagged object is expensive, and would greatly impede performance if it had to be handled every time an object is written.  To avoid this, objects are tagged whenever <i>any</i> write occurs, so that any additional writes before the next garbage-collection can proceed without interruption.</p>