<p>The standard places restrictions on the interface of the standard library, not the implementation.  It goes out of its way to make it clear that standard library headers can do things user code can not... <code>__MACRO__NAME__</code> is reserved for the implementation, for instance.  And obviously, only the implementation can actually put all these functions and types into namespace std.</p>

<p>Mostly, a "portable" implementation could be written.  But it would likely be less performant... as an easy example, consider the traditional implementation of the <code>offsetof</code> macro.  It generally involves dereferencing a null pointer, which is formally undefined behavior, but because the implementation knows how its platform works, that's okay.  A portable version can not do this, so it would have to actually create a new instance of the provided type to keep everything on the up and up.</p>

<p>Quite a few type traits in C++0x likely require compiler support, which makes a "portable" implementation somewhere between difficult and impossible.  There's no standard way to analyze if an arbitrary type is POD, for instance, which is why <code>boost::is_pod</code> requires user support via specialization on some platforms.</p>

<p>There is also the consideration that a lot of the standard library is not header-only.  The other bits can be written in a completely different language... so long as it all links together properly, it doesn't matter.  If the runtime is implemented in Lisp, obviously it won't be C++ compliant code that can be reliably dropped into a different compiler toolchain.</p>