<p>In my experience of using gcc on Windows, you can avoid a lot of this overhead by avoiding allocation of memory or the potential for allocation of memory in your inner loops. The other answers point out that you get these calls when an exception might be thrown and cause calls to destructors. In my programs the exception that could be thrown in the most places is std::bad_alloc which you get when a memory allocation fails.</p>

<p>So if the potential exceptions in your program are also mostly std::bad_alloc, and you can move the allocation or the potential for an allocation out of your inner loop, then GCC won't have to deal with cleaning up after potential std::bad_alloc exceptions inside your inner loop. That should speed things up. Remember to consider that things like vector::push_back can allocate memory. Even if you call vector::reserve first to rule out reallocations, GCC might not be smart enough to realize that reallocation isn't going to happen.</p>

<p>I don't know what version of GCC you are using, but I believe that the newest version of GCC uses an exception handling mechanism that does not have this overhead. I could be wrong on that, though. It is certainly possible to implement an exception handling mechanism that does not require registering destructors dynamically since the destructors that need to be called can be inferred from the program counter.</p>