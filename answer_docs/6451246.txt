<p>You need two things to safely use an object concurrently by two threads or more: atomicity of operations and ordering guarantees.</p>

<p>Some people will pretend that on some platforms what you're attempting here is safe because e.g. operations on whatever type <code>int</code> stands for those platforms are atomic (even incrementing or whatever). The problem with this is that you don't necessarily have ordering guarantees. So while <em>you</em> want and know that this particular variable is going to be accessed concurrently, the <em>compiler</em> doesn't. (And the compiler is right to assume that this variable is going to be used by only one thread at a time: you don't want every variable to be treated as being potentially shared. The performance consequences would be terrible.)</p>

<p>So don't use primitive types this way. You have no guarantees from the language and even if some platforms have their own guarantees (e.g. atomicity) you have no way of telling the compiler that the variable is shared with C++. Either use compiler extensions for atomic types, the C++0x atomic types, or library solutions (e.g. mutexes). And don't let the name mislead you: to be truly useful, an atomic type has to provide ordering guarantees along with the atomicity that comes with the name.</p>