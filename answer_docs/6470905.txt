<p>The behavior you see in your database is possible because the ID generation and row insertion are atomic.  If you want to have this behavior in your application, then I suggest you only get the ID immediately before storing the data.  This will reduce your "transaction scope" to the minimum possible window, and should prevent any exceptions from interfering.</p>

<p>If for some bad reason this isn't possible, an alternative might be to have an "ID broker" that caches the ID counter.  It would read the current counter from the file, increment it by some number (say 100), then hand out successive IDs to all callers through a single-threaded method.  When it has handed out all 100, it updates the file again.  At shutdown, it would write the file one last time, using the last value it handed out.  The only problem then is if your system crashes you wind up with a gap in your IDs, but there are ways to compensate for that.</p>