<p>Here are a few basic ideas:</p>

<p>Of course you need a Team object. And you need a Schedule object. Then I would recommend a couple of implementation choices from the Design Patterns book. One would be to use the Builder pattern. You would have a ScheduleMaker and then you could have different concrete builders. For instance, in Football, there are rules about the schedule: each team is going to play 2 games against each peer in its division. Generally different concrete Builders are used to provide for different physical variances. For example, in the Go4 book, the example is of a MazeBuilder where simple and complex implementations contain different numbers of doors, halls, etc. In your case, you would want to have perhaps different rule-oriented ways of making the schedule. For the example I gave, you would push a method called 'setupDivisionalGames' into the interface, then you could fill the rest of the schedule with randomly selected rivals who are not from within the division. (Builder is generally buildA, buildB... getProduct().)</p>

<p>If this is starting to sound like another pattern, a simpler implementation would be to just have a Strategy pattern for picking opponents. If you don't have rules like the one above, then a simple random Strategy would be a good default implementation and if you wanted to get more fancy, you could just unit test a new implementation and change no other code and get new schedules.</p>

<p>Finally, think about the possibility of doing a score-based approach. That's how the NFL works. If you are the Detroit Lions, your schedule is going to be more cush than if you are the Packers this coming season. Either Builder or Strategy would let you do something like that pretty easily: the team's relative score must be close to the average score of all opponents, something like that. </p>