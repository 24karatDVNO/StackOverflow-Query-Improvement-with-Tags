<p>Your approach appears to be to create a bunch of shifted streams and add them up. This would conceivably work if you knew how many elements you want to take, but if the number of elements is indeterminate, you can't create an infinite number of these streams, of course!</p>

<p>Another approach would be to maintain a list of streams you're adding from at each point, call it <code>current-streams</code>, starting with <code>(list integers)</code>. Then at each step you <code>(cons integers current-streams)</code>, obtain the next partial sum with <code>(apply + (map head current-streams))</code>, and recurse with <code>current-streams</code> changing to <code>(map tail current-streams)</code>. This way you only add series as you really need them, rather than trying to create an infinite number of streams up-front. But this is a resource-intensive approach, since the number of streams you need to track will just keep growing and growing.</p>

<p>It would be nice if you could sum up a fixed number of streams (ideally two, with the function you wrote!) to get the output you wanted. Note that at each step through the output, the previous step has most of the partial sum you need already calculated for you... if you can find some way of using streams to take advantage of that. Try writing down the recurrence relationship between successive elements of the <code>partSums</code> sequence, with the help of the <code>integers</code> sequence you've already defined, and see if that leads you to a possibly different streaming approach...</p>