<p>Because your instruction set is so small, and based on the thread from the mguica answer, I would say the next step is to continue and/or fully test your instruction set.  do you have flags?  do you have branch instructions.  For now just hand generate the machine code.  Flags are tricky, in particular the overflow (V) bit.  You have to examine carry in and carry out on the msbit adder to get it right.  Because the instruction set is small enough you can try the various combinations of back to back instructions and followed by or and followed by xor and followed by add, or followed by and or followed by xor, etc.  And mix in the branches.  back to flags, if the xor and or for example do not touch carry and overflow then make sure you see carry and overflow being a zero and not touched by logical instructions and carry and overflow being one and not touched, and also independently show carry and overflow are separate, one on one off, not touched by logical, etc.  make sure all the conditional branches only operate on that one condition, lead into the various conditional branches with flag bits that are ignored in both states insuring that the conditional branch ignores them.  Also verify that if the conditional branch is not supposed to modify them that it doesnt.   likewise if the condition doesnt cause a branch that the conditional flags are not touched...</p>

<p>I like to use randomization but it may be more work than you are after.  I like to independently develop a software simulator of the instruction set, which I find easier to use that the logic also sometimes easier to use in batch testing.  you can then randomize some short list of instructions, varying the instruction and the registers, naturally test the tester by hand computing some of the results, both state of registers after test complete and state of flag bits.  Then make that randomized list longer, at some point you can take a long instruction list and run it on the logic simulator and see if the logic comes up with the same register results and flag bits as the instruction set simulator, if they vary figure out why.  If the do not try another random sequence, and another.  Filling registers with prime numbers before starting the test is a very good idea.</p>

<p>back to individual instruction testing and flags go through all the corner cases 0xFFFF + 0x0000 0xFFFF+1, things like that places just to the either side of and right on operands and results that are one count away from where a flag changes at the point where the flag changes and just the other side of that.  for the logicals for example if they use the zero flag, then have various data patterns that test results that are on either side of and at zero 0x0000, 0xFFFF 0xFFFE 0x0001 0x0002, etc.  Probably a walking ones result as well 0x0001 result 0x0002, ox0004, etc.</p>

<p>hopefully I understood your question and have not pointed out the obvious or what you have already done thus far.</p>