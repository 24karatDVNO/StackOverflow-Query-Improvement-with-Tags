<p>If I understand the question correctly, you are looking for a double-ended queue (<em>deque</em>). There is papers by Okasaki, Kaplan and Tarjan about purely functional deques. As for the implementations, the easiest is I think to take the default implementation of <code>collection.immutable.IndexedSeq</code> which is <code>collection.immutable.Vector</code>, according to <a href="http://www.scala-lang.org/docu/files/collections-api/collections_40.html" rel="nofollow">this table</a> having estimated constant costs for <code>head</code> and <code>last</code> (it says <code>tail</code> but i would guess that <code>last</code> is also O(1)).</p>

<p>The Okasaki/ Kaplan/ Tarjan one seems to have been implemented by <a href="http://code.google.com/p/scala-deque/" rel="nofollow">Henry Ware</a>.</p>

<p>The other implementation that comes to mind is the <em>FingerTree</em> by Hintze, for which various implementations in scala exist. <a href="https://github.com/scalaz/scalaz" rel="nofollow">Scalaz</a> has one which some time ago I put into <a href="https://github.com/Sciss/FingerTree" rel="nofollow">a separate package</a> since I use it a lot. According to a presentation by Daniel Spiewak (I don't remember where I saw this), the FingerTree is pretty slow though in the constant time factors -- and also the page by Henry Ware says that its slower than his other implementation.</p>