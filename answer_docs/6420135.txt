<p>See <a href="http://developer.android.com/reference/android/view/View.html#setOnTouchListener%28android.view.View.OnTouchListener%29" rel="nofollow">View#setOnTouchListener()</a> and <a href="http://developer.android.com/reference/android/view/View.OnTouchListener.html" rel="nofollow">View.OnTouchListener</a>.  When you receive a <code>MotionEvent</code> with <code>ACTION_DOWN</code>, you would start some repetition (e.g., create a <code>Handler</code> in your Activity, and call <a href="http://developer.android.com/reference/android/os/Handler.html#sendMessageDelayed%28android.os.Message,%20long%29" rel="nofollow">Handler#sendMessageDelayed()</a>, where the delay is whatever repeat delay you want to use.  As each message is received, you would first perform your key dispatches, and then call <code>sendMessageDelayed()</code> again to schedule the next key press.  On <code>MotionEvent.ACTION_UP</code>, you would call <a href="http://developer.android.com/reference/android/os/Handler.html#removeMessages%28int%29" rel="nofollow">Handler#removeMessages()</a> to cancel the pending scheduled event.</p>

<p>As for simulating the keypress events, the <code>dispatchKeyEvent()</code> method you described might work, depending on what you want to achieve:  would have to explain further, if that doesn't work for you.</p>